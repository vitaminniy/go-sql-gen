// go-sql-scan is a tool to automate the creation of methods that
// scan database/sql.Rows into objects and slices of objects.

package main

import (
	"flag"
	"go/ast"
	"go/parser"
	"go/token"
	"io"
	"log"
	"os"
	"reflect"
	"regexp"
	"strings"
	"text/template"
)

const suffix = "sql_scan"
const tmpl = `// Code generated by go-sql-gen. DO NOT EDIT.

package {{.Package}}

import (
	"context"
	"database/sql"
)

{{range .Structs}}
// Get{{.Name}}Context returns element of type {{.Name}}.
//
// The following fields order in result-set expected:
// {{range $i, $s := .Fields}}{{if gt $i 0}},{{end}}{{$s}}{{end}}
func Get{{.Name}}Context(ctx context.Context, db *sql.DB, query string, args ...interface{}) (result {{.Name}}, err error) {
	err = db.QueryRowContext(ctx, query, args...).Scan({{range $i, $s := .Fields}}{{if gt $i 0}}, {{end}}&result.{{$s}}{{end}})
	return result, err
}

// Get{{.Name}}ListContext returns slice of elements of type {{.Name}}.
//
// The following fields order in result-set expected:
// {{range $i, $s := .Fields}}{{if gt $i 0}},{{end}}{{$s}}{{end}}
func Get{{.Name}}ListContext(ctx context.Context, db *sql.DB, query string, args ...interface{}) (result []{{.Name}}, err error) {
	rows, err := db.QueryContext(ctx, query, args...)
	if err != nil {
		return nil, err
	}
	defer rows.Close()

	for rows.Next() {
		var item {{.Name}}
		if err := rows.Scan({{range $i, $s := .Fields}}{{if gt $i 0}}, {{end}}&item.{{$s}}{{end}}); err != nil {
			return nil, err
		}
		result = append(result, item)
	}

	return result, err
}
{{end}}`

var (
	templater        = template.Must(template.New("").Parse(tmpl))
	match            = flag.String("m", ".", "pattern for matching struct names")
	ignoreUnexported = flag.Bool("i", false, "ignore unexported struct fields")
)

func main() {
	log.SetFlags(0)
	log.SetPrefix("go-sql-scan: ")

	flag.Parse()

	args := flag.NArg()
	if args == 0 {
		log.Fatalln("no files provided")
	}

	re := regexp.MustCompile(*match)

	for i := 0; i < args; i++ {
		fn := flag.Arg(i)

		if !strings.HasSuffix(fn, ".go") || strings.HasSuffix(fn, suffix+".go") {
			continue
		}

		f, err := os.Open(fn)
		if err != nil {
			log.Printf("couldn't open %s: %v\n", fn, err)
		}

		pf, err := parseFile(f, re, *ignoreUnexported)
		if err != nil {
			log.Printf("couldn't parse file %s: %v\n", fn, err)
			continue
		}

		if err := f.Close(); err != nil {
			log.Printf("couldn't close %s: %v\n", fn, err)
		}

		newFn := strings.Replace(fn, ".go", "_"+suffix+".go", 1)
		file, err := os.Create(newFn)
		if err != nil {
			log.Printf("couldn't create %s: %v\n", newFn, err)
			continue
		}

		if err := templater.Execute(file, pf); err != nil {
			log.Printf("couldn't execute template on file %s: %v\n", fn, err)
		}

		if err := file.Close(); err != nil {
			log.Printf("couldn't finalize %s: %v\n", newFn, err)
		}
	}
}

type parsedFile struct {
	Package string
	Structs []parsedStruct
}

type parsedStruct struct {
	Name   string
	Fields []string
}

func parseFile(r io.Reader, re *regexp.Regexp, ignoreUnexported bool) (pf parsedFile, err error) {
	f, err := parser.ParseFile(token.NewFileSet(), "", r, parser.ParseComments)
	if err != nil {
		return pf, err
	}

	ast.Inspect(f, func(n ast.Node) bool {
		p, ok := n.(*ast.File)
		if ok {
			pf.Package = p.Name.Name
			return true
		}

		t, ok := n.(*ast.TypeSpec)
		if !ok {
			return true
		}

		if t.Type == nil {
			return true
		}

		if ok := re.MatchString(t.Name.Name); !ok {
			return true
		}

		st, ok := t.Type.(*ast.StructType)
		if !ok {
			return true
		}

		fields := make([]string, 0)
		for _, field := range st.Fields.List {
			for _, name := range field.Names {
				if ok := name.IsExported(); ignoreUnexported && !ok {
					continue
				}
				if rtag := field.Tag; rtag != nil && len(rtag.Value) > 0 {
					tag := reflect.StructTag(rtag.Value[1:])
					if tag.Get("go-sql-gen") == "-" {
						continue
					}
				}
				fields = append(fields, name.Name)
			}
		}

		pf.Structs = append(pf.Structs, parsedStruct{
			Name:   t.Name.Name,
			Fields: fields,
		})

		return true
	})

	return pf, nil
}
